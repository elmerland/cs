/**
 * Author: Elmer Landaverde, Scott Sines
 * PIDs: elmer, ssnies
 */

/*
 * esh - the 'pluggable' shell.
 *
 * Developed by Godmar Back for CS 3214 Fall 2009
 * Virginia Tech.
 */
#include <stdio.h>
#include <readline/readline.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "esh-sys-utils.h"
#include "esh.h"
#include "output.h"
#include "utils.h"
#include "builtin.h"
#include "plugin.h"

#define IN 0
#define OUT 1
#define NUM_BUILT_IN 6

/* -------------------------------------------------------------------------- */
// START - Functions added by us to give functionality to the shell.

/* List of pipeline structures that represent all the jobs of this shell. */
struct list jobs;

/* Pointer to a pipeline structure that represents the current foreground job */
struct esh_pipeline * fg_job = NULL;

/**
 * Counter that keep track of how many jobs are currently being executed. When
 * the job that is using the highest JID is finishes the job count should be 
 * decrease.
 */
int job_count = 0;

/**
 * Updates the command with the matching pid to the new status provided in the
 * arguments.
 * @param pid    The pid of the command to update.
 * @param status The new status of the command.
 */
static void update_command(pid_t pid, int status);

/**
 * Goes through every pipeline in the jobs list and analyses the state of the 
 * commands inside of the pipeline to determine the status of the job. When this
 * function ends the provided job structure will have its status variable set 
 * correctly.
 * @param job The job to analyze.
 */
static void update_job(struct esh_pipeline * job);

/**
 * This function will loop indeterminately until the foreground job has 
 * finished. When it is done it will transfer the foreground job to the 
 * background if necessary, then it will restore control of the terminal to the
 * shell.
 */
static void wait_for_fg_job(void);

/**
 * Determines if the foreground job is done. Returns true whenever the state of
 * the foreground job changes from running to stopped, killed or done.
 * @return  True if the foreground job had terminated.
 */
static bool is_foreground_job_done(void);

/**
 * Initial function that is called after user presses enter. This function is in
 * charge of parsing the command line inputs and calling or executing the
 * appropriate functions.
 * @param cline The command line struct that is generated by esh from the input.
 */
static void process_command_line(struct esh_command_line * cline);

/**
 * This function is called for each pipeline that the user typed into the
 * command line. It will split the pipeline into individual commands, set up a
 * pipe between each of the command and then call the 'command_handler' function
 * to run each of the commands.
 * @param pipe The pipe struct that is generated by esh for each pipeline.
 */
static void pipe_handler(struct esh_pipeline *pipe);

/**
 * This function is called for each command that the user typed into the command
 * line. Each command is execute as it is appropriate and their input or output
 * is also set accordingly.
 * @param cmd The command struct that is generated by esh for each command.
 */
static void command_handler(struct esh_command *cmd);

/**
 * Initializes the shell, it first sets the handlers to all the appropriate 
 * signals. It then sets the shell in its own process group  and makes sure that
 * the shell has control of the terminal.
 * @param esh_shell A pointer the shell structure.
 */
static void init_esh(struct esh_shell * shell);

/**
 * This function handles the SIGCHLD signal that are produced by child 
 * processes. It get the command structure that corresponds to the child process
 * sending the signal and sets the status of the command appropriately. Then it
 * updates the job that the command belongs to.
 * @param signo   The signal to handle.
 * @param info    Information regarding the signal sent.
 * @param context The context of the signal.
 */
static void child_handler(int signo, siginfo_t* info, void* context);

/**
 * This function first determines if the given command is one of the built in
 * commands. If this is the case, then this function runs the function 
 * associated with the built in command.
 * @param  cmd The command.
 * @return     True if the command is a built in command, false otherwise.
 */
static bool is_built_in(struct esh_command * cmd);

// END - Functions added by us to give functionality to the shell.
/* -------------------------------------------------------------------------- */

/**
 * Prints the usage description for esh.
 * @param progname The name of the program.
 */
static void usage(char *progname) {
  printf("Usage: %s -h\n"
    " -h            print this help\n"
    " -p  plugindir directory from which to load plug-ins\n",
    progname);

  exit(EXIT_SUCCESS);
}

/* Build a prompt by assembling fragments from loaded plugins that 
 * implement 'make_prompt.'
 *
 * This function demonstrates how to iterate over all loaded plugins.
 */
static char * build_prompt_from_plugins(void) {
  char *prompt = NULL;
  struct list_elem * e = list_begin(&esh_plugin_list);

  for (; e != list_end(&esh_plugin_list); e = list_next(e)) {
    struct esh_plugin *plugin = list_entry(e, struct esh_plugin, elem);

    if (plugin->make_prompt == NULL)
      continue;

    /* append prompt fragment created by plug-in */
    char * p = plugin->make_prompt();
    if (prompt == NULL) {
      prompt = p;
    } else {
      prompt = realloc(prompt, strlen(prompt) + strlen(p) + 1);
      strcat(prompt, p);
      free(p);
    }
  }

  /* default prompt */
  if (prompt == NULL)
    prompt = strdup("esh> ");

  return prompt;
}

/**
 * List of built in functions that are supported by esh.
 */
static built_in built_in_list[NUM_BUILT_IN] = {
  {"jobs", .built_in_func = built_in_jobs},
  {"fg", .built_in_func = built_in_fg},
  {"bg", .built_in_func = built_in_bg},
  {"exit", .built_in_func = built_in_exit},
  {"kill", .built_in_func = built_in_kill},
  {"stop", .built_in_func = built_in_stop}
};

// The shell object plugins use.
// Some methods are set to defaults.
 
struct esh_shell shell = {
  .build_prompt = build_prompt_from_plugins,
  .readline = readline,       /* GNU readline(3) */ 
  .parse_command_line = esh_parse_command_line, /* Default parser */
  .get_jobs = get_jobs,
  .get_job_from_jid = get_job_from_jid,
  .get_job_from_pgrp = get_job_from_pgrp,
  .get_cmd_from_pid = get_cmd_from_pid
};

/**
 * Main functions that executes esh and keep getting new command lines from
 * the user.
 * @param  ac The number of arguments being passed to esh.
 * @param  av The list of arguments being passed to esh.
 * @return    Zero if successful.
 */
int main(int ac, char *av[]) {
  int opt;
  list_init(&esh_plugin_list);

  /* Process command-line arguments. See getopt(3) */
  while ((opt = getopt(ac, av, "hp:")) > 0) {
    switch (opt) {
    case 'h':
      usage(av[0]);
      break;

    case 'p':
      esh_plugin_load_from_directory(optarg);
      break;
    }
  }

  // Initialize all the plugins.
  esh_plugin_initialize(&shell);

  // Initialize the shell.
  init_esh(&shell);
  // Initialize the jobs list.
  list_init(&jobs);

  /* Read/eval loop. */
  for (;;) {
    /* Do not output a prompt unless shell's stdin is a terminal */
    char * prompt = isatty(0) ? shell.build_prompt() : NULL;
    char * cmdline = shell.readline(prompt);
    free (prompt);

    if (cmdline == NULL) { /* User typed EOF */
      break;
    }

    // Run any plugins that support raw command line.
    plugin_process_raw_cmdline(&cmdline);

    // Parse the command line.
    struct esh_command_line * cline = shell.parse_command_line(cmdline);
    // Free the raw command line.
    free (cmdline);

    // Check if the command line was parsed successfully.
    if (cline == NULL){                  /* Error in command line */
      printf("Error in command line\n");
      continue;
    }

    // Check if command line is empty.
    if (list_empty(&cline->pipes)) {    /* User hit enter */
      esh_command_line_free(cline);
      continue;
    }

    // Process the command line.
    process_command_line(cline);

    // Free the command line.
    esh_command_line_free(cline);
  }
  return 0;
}

void set_fg_job(struct esh_pipeline * new_fg) {
  // Set the foreground job to the new pointer.
  fg_job = new_fg;
}

struct esh_pipeline * get_fg_job(void) {
  // Return the pointer to the foreground job.
  return fg_job;
}

struct list/* <esh_pipeline> */ * get_jobs(void) {
  // Return pointer to the jobs list.
  return &jobs;
}

struct esh_pipeline * get_job_from_jid(int jid) {
  // Block child signal.
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  struct esh_pipeline * result = NULL;
  struct list_elem * job = list_begin(&jobs);
  // Iterate through all the jobs.
  for (; job != list_end(&jobs); job = list_next(job)) {
    // Get the pipeline structure
    struct esh_pipeline * pipeline = list_entry(job, struct esh_pipeline, elem);
    // Check if pipeline JID matches
    if (pipeline->jid == jid) {
      result = pipeline;
      break;
    }
  }

  // Unblock child signal.
  unblock_sigchld(prev_blocked);

  return result;
}

struct esh_pipeline * get_job_from_pgrp(pid_t pgrp) {
  // Block child signal.
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  struct esh_pipeline * result = NULL;
  struct list_elem * job = list_begin(&jobs);
  // Iterate through all the jobs.
  for (; job != list_end(&jobs); job = list_next(job)) {
    // Get the pipeline structure
    struct esh_pipeline * pipeline = list_entry(job, struct esh_pipeline, elem);
    // Check if pipeline JID matches
    if (pipeline->pgrp == pgrp) {
      result = pipeline;
      break;
    }
  }

  // Unblock child signal
  unblock_sigchld(prev_blocked);

  return result;
}

struct esh_command * get_cmd_from_pid(pid_t pid) {
  // Check if signal was previously blocked.
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  // Look in the jobs list for the command

  struct esh_command * result = NULL;
  struct list_elem * job_elem = list_begin(&jobs);
  // Iterate through all the jobs in the jobs list.
  for (; job_elem != list_end(&jobs); job_elem = list_next(job_elem)) {

    // Get the pipeline structure
    struct esh_pipeline * job_struct = 
      list_entry(job_elem, struct esh_pipeline, elem);

    struct list_elem * cmd_elem = list_begin(&job_struct->commands);
    // Iterate through all the commands in the pipeline.
    for (; cmd_elem != list_end(&job_struct->commands); 
        cmd_elem = list_next(cmd_elem)) {
      // Get the command structure.
      struct esh_command * cmd_struct =
        list_entry(cmd_elem, struct esh_command, elem);

      // Check if the pids match
      if (cmd_struct->pid == pid) {
        result = cmd_struct;
        break;
      }
    }
    if (result != NULL) {
      break;
    }
  }

  // if the command was not found in the jobs list, check if the command is in
  // the foreground process.
  if (result == NULL) {
    struct list_elem * fg_cmd_elem = list_begin(&fg_job->commands);
    // Iterate through all the commands in the foreground job.
    for (;fg_cmd_elem != list_end(&fg_job->commands); 
        fg_cmd_elem =list_next(fg_cmd_elem)) {
      // Get command structure
      struct esh_command * fg_cmd_struct = 
        list_entry(fg_cmd_elem, struct esh_command, elem);
      // Check if the pids match
      if (fg_cmd_struct->pid == pid) {
        result = fg_cmd_struct;
        break;
      }
    }
  }

  // Unblock child signal.
  unblock_sigchld(prev_blocked);

  return result;
}

void add_job(struct list_elem * new_job) {
  // Block child signal
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  // Get the pipeline structure.
  struct esh_pipeline * pipeline =
    list_entry(new_job, struct esh_pipeline, elem);

  // Check if the pipeline has a JID
  if (pipeline->jid == -1) {
    // If not JID has being set, then send job to back of the list and give it
    // a new JID.
    list_push_back(&jobs, new_job);
    pipeline->jid = ++job_count;
  } else {
    // If job already has a JID, then find the right position in the jobs list
    // to put the new job.
    struct list_elem * curr_node = list_begin(&jobs);
    // Iterate through all the jobs, until the JID of the job is greater than
    // the JID of the job to be inserted.
    while (curr_node != list_end(&jobs) && 
        pipeline->jid > list_entry(curr_node, struct esh_pipeline, elem)->jid) {
      curr_node = list_next(curr_node);
    }
    // Insert new job before the current node.
    list_insert(curr_node, new_job);
  }

  // Unblock child signal.
  unblock_sigchld(prev_blocked);
}

void remove_job(pid_t pgrp) {
  // Block child signal
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  // Get the pipeline structure for the terminated job.
  struct esh_pipeline * terminated_job = get_job_from_pgrp(pgrp);
  // Remove the job from the jobs list.
  list_remove(&terminated_job->elem);

  // Unblock the child signal.
  unblock_sigchld(prev_blocked);
}

void trim_jobs_list(bool print_job) {
  // Block child signal
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  struct list_elem * job_elem = list_begin(&jobs);
  // Iterate through all the jobs.
  while (job_elem != list_end(&jobs)) {
    // Get the job structure.
    struct esh_pipeline * job_struct = 
      list_entry(job_elem, struct esh_pipeline, elem);
    // Check if job has terminated.
    if (job_struct->status == DONE || job_struct->status == KILLED) {
      // If print flag is set to true, then print job.
      if (print_job) {
        print_single_job(job_struct, true);
      }
      // Remove the job from the jobs list.
      job_elem = list_remove(job_elem);
      // Free pipeline structure.
      esh_pipeline_free(job_struct);
    } else {
      // Get next job.
      job_elem = list_next(job_elem);
    }
  }

  // Update JID counter
  if (list_empty(&jobs)) {
    // If the jobs list is empty then reset the job counter to zero.
    job_count = 0;
  } else {
    // Otherwise set the job counter to the JID of the last job in the jobs list
    job_count = list_entry(list_back(&jobs), struct esh_pipeline, elem)->jid;
  }

  // Check the JID of the foreground process, if it is greater than the job
  // counter, then set the job counter to the JID of the foreground process.
  if (fg_job != NULL && fg_job->jid > job_count) {
    job_count = fg_job->jid;
  } 

  // Unblock child signal.
  unblock_sigchld(prev_blocked);
}

static void init_esh(struct esh_shell * shell) {
  // This code was mostly adapted from the GNU manual. Section 27.6.2 
  // Initializing the shell. URL:
  // http://www.gnu.org/software/libc/manual/html_node/
  // Initializing-the-Shell.html
  
  // Ignore signals
  signal(SIGTERM, SIG_IGN); // Polite way of asking program to stop
  signal(SIGQUIT, SIG_IGN); // Same as SIGINT
  signal(SIGINT, SIG_IGN);  // Interrupt from keyboard
  signal(SIGTSTP, SIG_IGN); // Stop types from keyboard
  signal(SIGTTIN, SIG_IGN); // Request for terminal input
  signal(SIGTTOU, SIG_IGN); // Request for terminal output

  // Handler function for SIGCHLD.
  esh_signal_sethandler(SIGCHLD, child_handler);

  // Get the shell pgid.
  shell->pgid = getpgid(getpid());
  
  // Get control from the terminal
  if (tcsetpgrp(STDIN_FILENO, shell->pgid) == -1) {
    perror("Init_esh: Could not set terminal control properly");
    exit(1);
  }

  // Save default terminal state for shell
  shell->terminal_state = *esh_sys_tty_init();
}

static void update_job(struct esh_pipeline * job) {
  // Block child signal.
  bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
  block_sigchld(prev_blocked);

  // Initialize counters for the number of commands in all the possible status.
  int cmd_ctr = list_size(&job->commands);
  int done_ctr = 0;
  int kill_ctr = 0;
  int stp_ctr = 0;
  int run_ctr = 0;

  // Iterate through every command and get their status.
  struct list_elem * cmd_elem = list_begin(&job->commands);
  for (; cmd_elem != list_end(&job->commands); cmd_elem = list_next(cmd_elem)) {
    struct esh_command * cmd = list_entry(cmd_elem, struct esh_command, elem);
    switch (cmd->status) {
      case CMD_RUNNING: {
        run_ctr++;
        break;
      }
      case CMD_DONE: {
        done_ctr++;
        break;
      }
      case CMD_KILLED: {
        kill_ctr++;
        break;
      }
      case CMD_STOPPED: {
        stp_ctr++;
        break;
      }
      default: {
        errno = EINVAL;
        perror("Command status is unknown");
        exit(1);
      }
    }
  }

  // Check if all process are done
  if (run_ctr > 0) {
    // Set status to background only if job is background process.
    if (job->bg_job) {
      job->status = BACKGROUND;
    } else {
      job->status = FOREGROUND;
    }
  } else if (done_ctr == cmd_ctr) {
    // Set status to done if all processes are done.
    job->status = DONE;
  } else if ((done_ctr + stp_ctr) == cmd_ctr) {
    // Set status to stopped if at least one command is stopped.
    job->status = STOPPED;
  } else if ((done_ctr + kill_ctr) == cmd_ctr) {
    // Set status to killed if at least one command is killed.
    job->status = KILLED;
  } else if ((done_ctr + stp_ctr + kill_ctr) == cmd_ctr) {
    // Set status to stopped if at least one command is stopped.
    job->status = STOPPED;
  }

  // Unblock child signal.
  unblock_sigchld(prev_blocked);
}

static void wait_for_fg_job (void) {
  // Loop until the foreground job has terminated or has being stopped.
  while(!is_foreground_job_done()) {
    // Block child signal
    bool prev_blocked = esh_signal_is_blocked(SIGCHLD);
    block_sigchld(prev_blocked);

    // Wait for any process to change state
    int status;
    pid_t  pid;
    pid = waitpid(-1, &status, WCONTINUED|WUNTRACED);
    // Update the status of the command.
    update_command(pid, status);

    // Unblock child signal
    unblock_sigchld(prev_blocked);
  }
  // Check if the foreground job was stopped.
  if (fg_job->status == STOPPED) {
    // If the foreground job has stopped, then save the state of the terminal.
    esh_sys_tty_save(&fg_job->saved_tty_state);
    // Add job to the jobs list.
    add_job(&fg_job->elem);
    // Print line for stopped job.
    print_stopped_job(fg_job);
    // Set background status to false.
    fg_job->bg_job = true;
    // Set foreground job to null to indicate that there is no 
    // foreground process.
    fg_job = NULL;
  } else if (fg_job->status == KILLED || fg_job->status == DONE) {
    // Check if the foreground process was terminated.
    
    if (fg_job->status == KILLED) {
      // If the foreground process was killed output a newline.
      // This is just aesthetic so that the new prompt is not on top of the
      // "^C" symbol
      print_msg("\n");
    }
    // Free the pipeline structure for the foreground process.
    esh_pipeline_free(fg_job);
    // Set the foreground job to null.
    fg_job = NULL;
  }
  // Restore terminal state
  esh_sys_tty_restore(&shell.terminal_state);
  // Get control of terminal.
  if (tcsetpgrp(STDIN_FILENO, shell.pgid) == -1) {
    perror("Wait_fg: Could not set control of the terminal properly");
    exit(1);
  }
}

static void child_handler(int signo, siginfo_t* info, void* context) {
  int status;
  pid_t  pid;
  // Loop for as long as there are child process that have changed status.
  while ((pid = waitpid(-1, &status, WNOHANG|WCONTINUED|WUNTRACED)) > 0){
    // Update the status of the command.
    update_command(pid, status);
  }
}

static void update_command(pid_t pid, int status) {
  // Get the command 
  struct esh_command * cmd = get_cmd_from_pid(pid);
  // Check if command exist
  if (cmd == NULL) {
    errno = EINVAL;
    perror("Command not found in jobs list\n");
    exit(1);
  }

  // Notify plugins of child status change
  plugin_command_status_change(cmd, pid);

  // Check if process is done.
  if( WIFEXITED(status)) {
    // printf("Received signal that child process (%d) terminated. \n", pid);
    cmd->status = CMD_DONE;
  }

  // Check if process is stopped.
  if (WIFSTOPPED(status)) { 
    // printf("Received signal that child process (%d) stopped. \n", pid);
    cmd->status = CMD_STOPPED;
  }

  // Check if process is running.
  if (WIFCONTINUED(status)) {
    // printf("Received signal that child process (%d) continued. \n", pid);
    cmd->status = CMD_RUNNING;
  }

  // Check if process was killed.
  if( WIFSIGNALED(status)) {
    // printf("Received signal that child process (%d) received signal [%d] \n",
    //   pid, WTERMSIG(status));
    cmd->status = CMD_KILLED;
  }

  // Update the job status.
  update_job(cmd->pipeline);
}

static bool is_foreground_job_done(void) {
  // Check if the foreground job has being stopped or terminated.
  if (fg_job->status == DONE || fg_job->status == KILLED || 
      fg_job->status == STOPPED) {
    // Return true if the foreground job was stopped or terminated.
    return true;
  } else {
    return false;
  }
}

static void process_command_line(struct esh_command_line * cmdline) {
  // Iterate through every pipeline in the command list.
  while (!list_empty(&cmdline->pipes)) {
    // Pop the current list element.
    struct list_elem * e = list_pop_front(&cmdline->pipes);

    // Get the pipeline structure from the list element
    struct esh_pipeline * pipe = list_entry(e, struct esh_pipeline, elem);

    // Notify any plugins that support pipeline processing.
    plugin_process_pipeline(pipe);

    // Initialize the JID of the job.
    pipe->jid = -1;

    // Check if the pipeline is background or foreground.
    if (pipe->bg_job) {
      // Set status to background.
      pipe->status = BACKGROUND;
      // Add pipeline to jobs list
      add_job(e);
    } else {
      // Set status to foreground.
      pipe->status = FOREGROUND;
      // Update foreground job pointer.
      set_fg_job(pipe);
    }

    // Execute the pipeline structure.
    pipe_handler(pipe);

    // Run any plugins that use the pipeline after it has being forked.
    plugin_pipeline_forked(pipe);

    // Check if pipeline is foreground or background.
    if (!pipe->bg_job) {
      // If foreground job, then wait until foreground job is done.
      wait_for_fg_job();
    } else {
      // If background print background job statement.
      print_bg_job(pipe);
    }

    // Trim the jobs list.
    trim_jobs_list(true);
  }
}

static void pipe_handler(struct esh_pipeline * pipeline) {

  struct list_elem * e = list_begin (&pipeline->commands);

  // Copy terminal state to pipeline.
  pipeline->saved_tty_state = shell.terminal_state;

  // Create two flags to determine if command is first or last.
  bool is_first = true;
  bool is_last = false;

  /**
   * Create two pipes. The current command will write to out_fd and will
   * read from in_fd.
   */
  int out_fd[2];
  int in_fd[2];

  // Loop through every command in the pipeline.
  for (; e != list_end (&pipeline->commands); e = list_next (e)) {
    // Check if the current command is the last command in the list.
    if (list_next (e) == list_end (&pipeline->commands)) {
      is_last = true;
    }

    /**
     * Create the new pipe for the output of the current command only if
     * this is not the last command.
     * If this is the last command then the output should go to terminal
     * and a pipe is not necessary.
     */
    if (!is_last && pipe(out_fd) == -1) {
      // Check for error in the pipe function.
      perror("Pipe");
      exit(1);
    }

    // Get command structure
    struct esh_command *cmd = list_entry(e, struct esh_command, elem);

    // Check if command corresponds to a built in plugin.
    if(plugin_process_builtin(cmd)) {
      pipeline->status = DONE;
      continue;
    }

    // Check if command corresponds to a built it function.
    if (is_built_in(cmd)) {
      continue;
    }

    // Fork a new child.
    pid_t child = fork();
    // Check for error in the fork function.
    if (child == -1) {
      perror("Fork");
      exit(1);
    }
    else if (child == 0) {
      // For the first command only, set the process group ID.
      if (is_first) {
        pipeline->pgrp = getpid();
      }
      // Set the pgid of the command.
      setpgid(child, pipeline->pgrp);
      // Only for foreground process, set terminal control to process group.
      if (!pipeline->bg_job) {
        if (tcsetpgrp(STDIN_FILENO, getpgid(getpid())) == -1) {
          perror("Child_fork: Could not set control of terminal properly");
          exit(1);
        }
      }

      // Set signals back to default
      signal(SIGINT, SIG_DFL);  // Interrupt from keyboard
      signal(SIGQUIT, SIG_DFL); // Quit from keyboard
      signal(SIGTSTP, SIG_DFL); // Stop types from keyboard
      signal(SIGTTIN, SIG_DFL); // Request for terminal input
      signal(SIGTTOU, SIG_DFL); // Request for terminal output
      signal(SIGCHLD, SIG_DFL); // Child signal

      /**
       * If this is not the last child then the output file descriptor
       * should be changed to the newly created pipe.
       * If this is the last command, then its output should go to the
       * terminal and so there is not need for a pipe.
       */
      if (!is_last) {
        dup2(out_fd[OUT], OUT);
        close(out_fd[OUT]);
        close(out_fd[IN]);
      }

      /**
       * If this is not the first child then the input file descriptor
       * should be changed to the output pipe of the previous command.
       * The pipe in_fd represents the output pipe of the previous
       * command.
       * If this is the first command, then its input should come from
       * the terminal and so there is no need for a pipe.
       */
      if (!is_first) {
        dup2(in_fd[IN], IN);
        close(in_fd[IN]);
        close(in_fd[OUT]);
      }

      // Execute the command.
      command_handler(cmd);
      // If this is the child process then this call will never return.
    }

    // Set child pid.
    cmd->pid = child;
    // Set child status.
    cmd->status = CMD_RUNNING;

    // Only for the first command, get the process group ID.
    if (is_first) {
      pipeline->pgrp = child;
    }
    // Set the process group ID of the child process.
    setpgid(child, pipeline->pgrp);
    // Only for foreground processes, set the terminal control to the process
    // group.
    if (!pipeline->bg_job) {
      if (tcsetpgrp(STDIN_FILENO, getpgid(child)) == -1) {
        perror("Parent_fork: Could not set terminal control properly");
        exit(1);
      }
    }

    /**
     * If this is not the first command, then both the read and write
     * end of the in_fd pipe should be close. This is because the child
     * process already made a copy of this pipe, and the parent process
     * is about to replace this pipe with the output pipe of the current
     * command.
     */
    if (!is_first) {
      close(in_fd[IN]);
      close(in_fd[OUT]);
    }

    /**
     * Copy the file descriptors of the output pipe for the current
     * command to the input pipe of the next command. This way the next
     * command to be execute will read from the output pipe of the 
     * previous command.
     */
    in_fd[IN] = out_fd[IN];
    in_fd[OUT] = out_fd[OUT];

    /**
     * Set the is_first flag to false. This flag should only be true for
     * the first loop, and false for every loop after.
     */
    is_first = false;
  }
}

static void command_handler(struct esh_command *cmd) {
  // Input redirection
  if (cmd->iored_input != NULL) {
    // Open file for read only.
    int fd_in = open(cmd->iored_input, O_RDONLY);
    if (fd_in == -1) {
      perror("Invalid input file");
      exit(1);
    }
    // Duplicate file descriptor and close unnecessary ones.
    dup2(fd_in, IN);
    close(fd_in);
  }

  if (cmd->iored_output != NULL) {
    int fd_out;
    // Open files for write only.
    if (cmd->append_to_output) {
      // Output redirection - append
      fd_out = open(cmd->iored_output, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR |
        S_IWUSR | S_IRGRP | S_IROTH);
    } else {
      //Output redirection - overwrite
      fd_out = open(cmd->iored_output, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR |
        S_IWUSR | S_IRGRP | S_IROTH);
    }
    if (fd_out == -1) {
      perror("Invalid output file");
      exit(1);
    }
    // Duplicate file descriptor and close unnecessary ones.
    dup2(fd_out, OUT);
    close(fd_out);
  }

  // Execute command.
  execvp(cmd->argv[0], cmd->argv);
  // Report error.
  perror("Unkown command");
  exit(1);
}

static bool is_built_in(struct esh_command * cmd) {
  int i = 0;
  // Iterate through built in commands array
  for (; i < NUM_BUILT_IN; i++) {
    // Check if function matches built in function.
    if (strcmp(built_in_list[i].func_name, cmd->argv[0]) == 0) {
      // Execute the built in command function
      built_in_list[i].built_in_func(cmd);
      return true;
    }
  }
  return false;
}
