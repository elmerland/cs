import realtimeweb.earthquakeservice.domain.Coordinate;
import realtimeweb.earthquakeservice.domain.Earthquake;
import realtimeweb.earthquakewatchers.WatcherParseException;
import java.io.IOException;
import java.util.ArrayList;
import realtimeweb.earthquakewatchers.WatcherService;
import java.io.FileInputStream;
import java.io.InputStream;
import realtimeweb.earthquakeservice.domain.History;
import realtimeweb.earthquakeservice.domain.Threshold;
import realtimeweb.earthquakeservice.exceptions.EarthquakeException;
import realtimeweb.earthquakeservice.domain.Report;
import realtimeweb.earthquakeservice.regular.EarthquakeService;

/**
 * The StreamManager class is in charge of dealing with everything relating to
 * streams. This class has three responsibilities:
 * <p>
 * 1 - Get data from the EarthquakeService and WatcherService <br>
 * 2 - Interpret data obtained from the services </br> <br>
 * 3 - Output information to System.out </br>
 * </p>
 * 
 * @author Elmer Landaverde
 * @version Sept 5, 2013
 */
public class StreamManager
{
	
	/**
	 * Token separator. The character used to split the watcher commands into
	 * individual tokens.
	 */
	private static String	delimeterCharacter	= " ";
	
	/**
	 * Determines if the watcher service has more commands that need to be
	 * retrieved.
	 */
	private static boolean	hasMoreCommands		= true;
	
	
	/**
	 * Gets the earthquake data from the indicated source.
	 * 
	 * @param offLine
	 *            If true, data will be obtained from a local file. If false,
	 *            data will be obtained from the on line earthquake service.
	 * @param fileName
	 *            The file name corresponding to the local file where the
	 *            earthquake information will be obtained from if the offLine
	 *            flag is set to false.
	 * @return A report of all the earthquakes that have occurred.
	 */
	public static Report getEarthquakeData(boolean offLine, String fileName)
	{
		try
		{
			if (offLine)
			{
				return StreamManager.getOffLineEarthquakeData(fileName);
			}
			else
			{
				return StreamManager.getOnLineEarthquakeData();
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return null;
		}
	}
	
	
	/**
	 * Obtain watcher commands from the indicated local file.
	 * 
	 * @param fileName
	 *            The file name of the text file where the watcher information
	 *            is stored.
	 * @return An ArrayList object of Strings, that contains a list of new
	 *         commands. Returns null if the file could not be found, if the
	 *         file could not be read, or watcher information could be obtained.
	 * @throws WatcherParseException
	 *             Exception generated by the WatcherService
	 * @throws IOException
	 *             Exception generated by the FileInputStream
	 */
	public static ArrayList<String> getWatcherData(String fileName)
		throws IOException,
		WatcherParseException
	{
		// Get input stream from watcher service.
		InputStream watcherCommandFile = new FileInputStream(fileName);
		WatcherService watcherService = WatcherService.getInstance(watcherCommandFile);
		// Get next set of commands.
		ArrayList<String> newCommands = watcherService.getNextCommands();
		// Check if the watcher service still has more commands.
		if (!watcherService.hasCommands())
		{
			hasMoreCommands = false;
		}
		return newCommands;
	}
	
	
	/**
	 * Determines if the watcher service has no more commands to be retrieved.
	 * 
	 * @return True if the watcher service has no more commands to be retrieved,
	 *         false if the watcher service still have more commands to be
	 *         retrieved.
	 */
	public static boolean hasMoreWatcherCommands()
	{
		return hasMoreCommands;
	}
	
	
	/**
	 * Takes a Report object and gives the relevant information to the
	 * earthquake handler so that the new earthquake events can be processed.
	 * 
	 * @param report
	 *            The Report object to be processed.
	 */
	public static void parseEarthquakeReport(Report report)
	{
		EqSpatial.getEarthquakeManager().addEarthquakeReport(report);
	}
	
	
	/**
	 * Takes a list of new watcher commands and determines what has to be done
	 * with each one of them. Then it invokes the necessary methods and passes
	 * the formated information.
	 * 
	 * @param cmds
	 *            The list of new watcher commands.
	 */
	public static void parseWatcherCmds(ArrayList<String> cmds)
	{
		if (cmds == null)
		{
			return;
		}
		else if (cmds.size() == 0)
		{
			return;
		}
		for (String cmd : cmds)
		{
			StreamManager.processCmd(cmd);
		}
	}
	
	
	/**
	 * Prints a string representation of the BST and binary tree.
	 * 
	 * @param watcherManager
	 *            The WatcherManager object to debug.
	 */
	public static void printDebug(WatcherManager watcherManager)
	{
		
		System.out.print(watcherManager.getBST().toString());
		System.out.print(watcherManager.getBinTree().toString());
	}
	
	
	/**
	 * Prints a message notifying of the insertion of a new earthquake. The
	 * message is only printed if the --all option was enabled.
	 * 
	 * @param earthquake
	 *            The earthquake object that was added to the heap.
	 */
	public static void printEarthquakeAdded(Earthquake earthquake)
	{
		Coordinate c = earthquake.getLocation();
		System.out.println("Earthquake inserted at " + c.getLongitude() + " "
			+ c.getLatitude());
	}
	
	
	/**
	 * Prints a message reporting the earthquake with the largest magnitude. If
	 * the Earthquake object is null, it displays a message for no record in max
	 * heap.
	 * 
	 * @param earthquake
	 *            The earthquake object
	 */
	public static void printMagnitudeQuery(Earthquake earthquake)
	{
		if (earthquake == null)
		{
			System.out.println("No record on MaxHeap");
		}
		else
		{
			System.out.println("Largest earthquake in past 6 hours: \nMagnitude "
				+ earthquake.getMagnitude() + " at "
				+ earthquake.getLocationDescription());
		}
	}
	
	
	/**
	 * Prints a message notifying the addition of a watcher user.
	 * 
	 * @param user
	 *            The WatcherUser object for the user that was added.
	 * @param addBST
	 *            Determines if the WatcherUser was added to the BST. If false,
	 *            the WatcherUser was added to the bin tree.
	 */
	public static void printWatcherAdded(WatcherUser user, boolean addBST)
	{
		System.out.print(user.getName() + " " + user.printCoordinates()
			+ " is added to the ");
		if (addBST)
		{
			System.out.println("BST");
		}
		else
		{
			System.out.println("bintree");
		}
	}
	
	
	/**
	 * Prints a message notifying that a watcher duplicate was detected.
	 * 
	 * @param user
	 *            The WatcherUser object for the duplicate user.
	 * @param bst
	 *            Determines if the duplicate was found in the BST. If false,
	 *            the duplicate was found in the bin tree.
	 */
	public static void printWatcherDuplicate(WatcherUser user, boolean bst)
	{
		if (bst)
		{
			System.out.print(user.getName());
		}
		else
		{
			System.out.print(user.printCoordinates());
		}
		System.out.print(" duplicates a watcher already in the ");
		if (bst)
		{
			System.out.println("BST");
		}
		else
		{
			System.out.println("bintree");
		}
	}
	
	
	/**
	 * Prints a message notifying that the watcher user was not found in the
	 * BST.
	 * 
	 * @param name
	 *            The name of the watcher that was not found.
	 */
	public static void printWatcherNotFound(String name)
	{
		System.out.println(name + " does not appear in the BST");
	}
	
	
	/**
	 * Prints a message that notifies a watcher of an earthquake that occurred
	 * nearby.
	 * 
	 * @param earthquake
	 *            The earthquake event.
	 * @param user
	 *            The user to report the earthquake to.
	 */
	public static void printWatcherNotification(Earthquake earthquake, WatcherUser user)
	{
		System.out.println(user.toString());
	}
	
	
	/**
	 * Print the header message for watcher notified.
	 * 
	 * @param earthquake
	 *            The earthquake event that happened.
	 */
	public static void printWatcherNotificationHeader(Earthquake earthquake)
	{
		System.out.println(earthquake.getLocationDescription()
			+ " is close to the following watchers:");
	}
	
	
	/**
	 * Prints a message notifying the removal of a watcher user from the BST.
	 * 
	 * @param user
	 *            The WatcherUser object for the user that was removed.
	 * @param displayCoordinates
	 *            Determines if the coordinates for the WatchUser should be
	 *            displayed in the message.
	 * @param delBST
	 *            Determines if the WatcherUser was added to the BST. If false,
	 *            the WatchUser was added to the bin tree.
	 */
	public static void printWatcherRemoved(
		WatcherUser user,
		boolean displayCoordinates,
		boolean delBST)
	{
		System.out.print(user.getName());
		if (displayCoordinates)
		{
			System.out.print(" " + user.printCoordinates());
		}
		System.out.print(" is removed from the ");
		if (delBST)
		{
			System.out.println("BST");
		}
		else
		{
			System.out.println("bintree");
		}
	}
	
	
	/**
	 * Prints a message that reports how many nodes where visited inside the bin
	 * tree.
	 * 
	 * @param numBinNodes
	 *            The number of bin tree nodes that were visited.
	 */
	public static void printWatcherVisitedNotification(int numBinNodes)
	{
		System.out.println("Watcher search caused " + numBinNodes
			+ " bintree nodes to be visited.");
	}
	
	
	/**
	 * Method included for testing purposes. This sets the hasMoreCommands flag
	 * to true, that way the main method in the EqSimple class can be called
	 * again and it will continue to get new commands.
	 */
	public static void resetWatcherHasMoreCommands()
	{
		hasMoreCommands = true;
	}
	
	
	/**
	 * Obtains the earthquake information from the indicated local file.
	 * 
	 * @param fileName
	 *            The name of the local file from where the earthquake
	 *            information will be obtained from.
	 * @return A Report object containing the earthquake information. Returns
	 *         null if the file could not be found, if file could not be read,
	 *         or if earthquake information could be obtained.
	 * @throws IOException
	 *             Exception generated by the FileInputStream
	 * @throws EarthquakeException
	 *             Exception generated by the EarthquakeService.
	 */
	private static Report getOffLineEarthquakeData(String fileName)
		throws IOException,
		EarthquakeException
	{
		// Get earthquake stream from earthquake service.
		InputStream normalEarthquakes = new FileInputStream(fileName);
		EarthquakeService earthquakeService =
			EarthquakeService.getInstance(normalEarthquakes);
		// Get the next earthquake report.
		Report latestQuakes =
			earthquakeService.getEarthquakes(Threshold.ALL, History.HOUR);
		return latestQuakes;
	}
	
	
	/**
	 * Obtains earthquake information from the on-line earthquake service.
	 * 
	 * @return A Report object containing the earthquake information. Returns
	 *         null if the earthquake information could not be obtained.
	 * @throws EarthquakeException
	 *             Exception generated by the EarthquakeService.
	 */
	private static Report getOnLineEarthquakeData()
		throws EarthquakeException
	{
		EarthquakeService earthquakeService = EarthquakeService.getInstance();
		
		Report latestQuakes =
			earthquakeService.getEarthquakes(Threshold.ALL, History.HOUR);
		return latestQuakes;
	}
	
	
	/**
	 * Takes one watcher command and determines what has to be done. Then it
	 * invokes the necessary class and passes the formated information.
	 * 
	 * @param cmd
	 *            The command to be processed.
	 */
	private static void processCmd(String cmd)
	{
		if (cmd == null || cmd.equals(""))
		{
			return;
		}
		// Get type of query
		if (cmd.startsWith("add" + StreamManager.delimeterCharacter))
		{
			// Get command tokens
			String[] addCmd = cmd.split(StreamManager.delimeterCharacter, 4);
			try
			{
				// Extract information.
				String name = addCmd[3];
				double longitude = Double.parseDouble(addCmd[1]);
				double latitude = Double.parseDouble(addCmd[2]);
				// Add user.
				EqSpatial.getWatcherManager().addUser(name, longitude, latitude);
			}
			catch (Exception e)
			{
				// Catch any exceptions from converting a string to a double.
				e.printStackTrace();
				return;
			}
		}
		else if (cmd.startsWith("delete" + StreamManager.delimeterCharacter))
		{
			// Get command tokens
			String[] delCmd = cmd.split(StreamManager.delimeterCharacter, 2);
			// Remove user.
			EqSpatial.getWatcherManager().removeUser(delCmd[1]);
		}
		else if (cmd.equals("debug"))
		{
			// Print debug information.
			StreamManager.printDebug(EqSpatial.getWatcherManager());
		}
		else if (cmd.equals("query"))
		{
			EqSpatial.getEarthquakeManager().queryEarthquakes();
		}
		else
		{
			return;
		}
	}
}
