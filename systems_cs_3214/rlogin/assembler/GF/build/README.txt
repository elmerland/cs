CS 2506 - Porf. McQuain
C programming assignment 4 - Assembler

Elmer Landaverde
ID: 9054-91691
PID: elmer@vt.edu

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Below is a brief description of how to call the assembler, which follows the 
restrictions specified in the project spec.

USAGE:
		assemble [--help] [-list|-symbols] [SOURCE] [DEST]

DESCRIPTION:
--help		Prints out this same description to the console and exits.

-list		Output a list representation to the destination file.

-symbols	Output a symbol representation to the destination file.

SOURCE		The file name of the input file that contains the MIPS
			instructions to be assembled.

DEST		The file name of the output file where the results of
			the assembler will be written to.
			NOTE: File does not have to exist.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Project Organization:

The file organization is as follows. All of the c files are located inside the
"src" directory. All of the header files are located inside the "include"
directory. The makefile automatically pulls all the resources from these two
directories and compiles them in two steps. The first step is to generate an
object file for each c file. These object files are stored in the same directory
that the makefile file is stored at. Then the executable is generated, and it is
also stored in the same directory as the makefile. The compiler has all the
warning flags turned on, but I dissabled the gdb flag for the final submission
file.

My project code is organized in the following way. The main source file is
called Assembler.c, this file contains all the main functions that call 
everything else. The main function first verifies that the arguments passed to
the program are valid, including the existence of the input file.

After the main function has validated the arguments the temporary files are
created. Only one temporary file is created called "clean.temp".

Next, the preprocessor is called. The preprocess is located in the
Preprocessor.c file and only has one function called preprocess(). This function
takes the input file and cleans all the non-essential information (empty spaces,
tabs, empty lines, etc. This function also replaces all the sudo instructions
with the actual real instructions. All this is written to the temporary file
created in the previous step.

Then, the parser is called. The parser is located in the Parser.c file and only
has one function parse(). This function reads from the clean file line by line
and populates three tables. These three tables are the variables table, 
instructions table, and symbols table. These three tables will eventually
contain all the information that the translator needs to turn every line into
binary. After the parser exits all three tables have being filled out with all
the necessary information.

The next call is to the translator. The translator is located in the 
Translator.c file and only has one function translate(). This function converts
the information in the three tables generated by the parser to a binary
representation of the data.

Finally, once the translator has done its job the output manager is called. The
output manager is located in the OutputManager.c file and has only one function
called print_output(). This function prints all three types of files (binary,
symbols, list). 

Once the output manager has printed the information to the output file, the 
temporary clean file is deleted. Then the arrays created for the tables are
deallocated from memory and the program exits.

Some things worth mentioning about my project is that there is header file named
Global.h which contains all of the typedef declarations and constants that are
used throughout the project. Also, the Tables.h and Tables.c files contain useful
tables to find the value of registers and the locations of parameters in
instructions. Lastly, there are three utilities flies: Utilities.c, 
BinaryUtilities.c, and StructUtilities.c. These files contain miscellaneous
functions that I felt did not belong in any of the other files because they are
too general and therefore could be used in the future for other projects or
other files.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Notes:

I tried to make my program as robust as possible, so if there is ever any error
it should print a message indicating the source of the error. Whenever an error
is encountered the program does its best to exit out gracefully. In the case
where the program encounters a unknown instruction or variable it will print a
message and then exit. Whenever the program exits, it attempts to deallocate
any memory that was allocated and close (delete) all files that were opened.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Coverage:

I tested my program against all the test files posted on the course website and
passed every test without any errors. I feel confident that you won't encounter
any errors in my program but if you do, you should get some helpful messages as
to what happened.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Extra credit:

I did implement the -list option. This options is implemented according to the
specifications of the project spec. The only thing worth noting is that when
printing strings, if these strings are not word aligned they will be padded with
zeros. Therefore if you have the label str1 that starts at address 0x2005 that
contains the string "abcd", the following will be printed:

S2:
0x00002005	01100011011000100110000100000000
0x00002008	00000000000000000000000001100100

As you can see, the first line was padded with zeros because it starts at
address 0x2005 and not 0x2004. And the second line was padded with zeros because
it ends at address 0x200C
